# Claude Statusline CLI Wizard — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add an interactive `npx claude-statusline` wizard that asks what data/layout/colors the user wants, previews the result, then writes `~/.claude/statusline-command.sh` and patches `~/.claude/settings.json`.

**Architecture:** Single `setup.js` entry point wiring `@clack/prompts`. Three pure helper modules (`generate.js`, `patch-settings.js`, `detect-credentials.js`) handle all testable logic. The wizard calls them in sequence. Generated output is a self-contained bash script — no runtime config file.

**Tech Stack:** Node.js 18+, `@clack/prompts` (wizard UI), `node:test` + `node:assert` (built-in test runner, no extra deps), bash (generated output)

---

## File Map

```
claude-statusline/
  setup.js                        # wizard entry point (bin)
  package.json                    # new
  lib/
    generate.js                   # generateScript(config) -> bash string
    patch-settings.js             # applyStatusLine(rawJson, path) -> string
    detect-credentials.js         # detectCredentials() -> boolean
  test/
    generate.test.js
    patch-settings.test.js
  statusline.sh                   # existing — keep as reference
  install.sh                      # simplified to delegate to wizard
  docs/plans/
    2026-02-19-statusline-cli-design.md
    2026-02-19-statusline-cli.md  # this file
```

---

## Config Schema (shared across all tasks)

```js
// Shape assembled by setup.js, passed to generateScript()
{
  fields: string[],       // subset of: 'model','tokenCounts','usedPct','remainingPct',
                          //   'linesChanged','contextBar','rateLimitBars','resetTimes'
  layout: 'single' | 'multi',
  colorStyle: 'traffic-light' | 'monochrome' | 'custom',
  thresholds: { yellow: number, red: number }  // only when colorStyle === 'custom'
}
```

---

### Task 1: Initialize package.json

**Files:**
- Create: `package.json`

**Step 1: Create package.json**

```json
{
  "name": "claude-statusline",
  "version": "1.0.0",
  "description": "Interactive wizard to configure your Claude Code status line",
  "type": "module",
  "bin": {
    "claude-statusline": "./setup.js"
  },
  "scripts": {
    "test": "node --test test/*.test.js"
  },
  "dependencies": {
    "@clack/prompts": "^0.9.0"
  },
  "engines": {
    "node": ">=18"
  }
}
```

**Step 2: Install dependencies**

```bash
cd ~/code/claude-statusline && npm install
```

Expected: `node_modules/@clack` appears, `package-lock.json` created.

**Step 3: Verify test runner works**

```bash
cd ~/code/claude-statusline && node --test 2>&1 | head -5
```

Expected: no crash (may say "no test files found").

**Step 4: Commit**

```bash
cd ~/code/claude-statusline
git add package.json package-lock.json
git commit -m "chore: initialize npm package with @clack/prompts"
```

---

### Task 2: lib/generate.js — core script generator

Pure function: takes config, returns a bash script string. No I/O — fully testable.

**Files:**
- Create: `lib/generate.js`
- Create: `test/generate.test.js`

**Step 1: Write failing tests**

```js
// test/generate.test.js
import { test } from 'node:test'
import assert from 'node:assert/strict'
import { generateScript } from '../lib/generate.js'

const base = {
  fields: ['model'],
  layout: 'single',
  colorStyle: 'monochrome',
  thresholds: { yellow: 50, red: 80 }
}

test('returns string starting with shebang', () => {
  assert.ok(generateScript(base).startsWith('#!/bin/bash'))
})

test('includes generated-by comment', () => {
  assert.ok(generateScript(base).includes('Generated by claude-statusline'))
})

test('monochrome omits ANSI color variables', () => {
  const s = generateScript({ ...base, colorStyle: 'monochrome' })
  assert.ok(!s.includes("G='\\033[32m'"))
})

test('traffic-light includes color variables', () => {
  const s = generateScript({ ...base, colorStyle: 'traffic-light' })
  assert.ok(s.includes("G='\\033[32m'"))
  assert.ok(s.includes("RED='\\033[31m'"))
})

test('custom thresholds appear in generated script', () => {
  const s = generateScript({ ...base, colorStyle: 'custom', thresholds: { yellow: 30, red: 60 } })
  assert.ok(s.includes('30'))
  assert.ok(s.includes('60'))
})

test('contextBar field includes bar() helper', () => {
  const s = generateScript({ ...base, fields: ['contextBar'] })
  assert.ok(s.includes('bar()'))
})

test('contextBar omitted when not in fields', () => {
  const s = generateScript({ ...base, fields: ['model'] })
  assert.ok(!s.includes('context:'))
})

test('rateLimitBars field includes fetch logic', () => {
  const s = generateScript({ ...base, fields: ['rateLimitBars'] })
  assert.ok(s.includes('USAGE_CACHE'))
  assert.ok(s.includes('fetch_usage_bg'))
})

test('no rateLimitBars means no fetch logic', () => {
  const s = generateScript({ ...base, fields: ['model', 'contextBar'] })
  assert.ok(!s.includes('fetch_usage_bg'))
})

test('linesChanged field uses lines_added variable', () => {
  const s = generateScript({ ...base, fields: ['linesChanged'] })
  assert.ok(s.includes('lines_added'))
})

test('multi layout produces line1 and line2 variables', () => {
  const s = generateScript({ fields: ['model', 'contextBar'], layout: 'multi', colorStyle: 'monochrome', thresholds: { yellow: 50, red: 80 } })
  assert.ok(s.includes('line1='))
  assert.ok(s.includes('line2='))
})

test('single layout produces only line1 variable', () => {
  const s = generateScript({ fields: ['model', 'tokenCounts'], layout: 'single', colorStyle: 'monochrome', thresholds: { yellow: 50, red: 80 } })
  assert.ok(s.includes('line1='))
  assert.ok(!s.includes('line2='))
})
```

**Step 2: Run to confirm all fail**

```bash
cd ~/code/claude-statusline && node --test test/generate.test.js
```

Expected: `ERR_MODULE_NOT_FOUND` — `lib/generate.js` doesn't exist yet.

**Step 3: Create `lib/generate.js`**

```js
// lib/generate.js
// Pure function: config -> bash script string. No I/O.

export function generateScript(config) {
  const { fields, layout, colorStyle, thresholds = { yellow: 50, red: 80 } } = config

  const hasColors       = colorStyle !== 'monochrome'
  const needsBar        = fields.includes('contextBar') || fields.includes('rateLimitBars')
  const needsFmt        = fields.includes('tokenCounts') || fields.includes('usedPct') || fields.includes('remainingPct')
  const needsRateLimits = fields.includes('rateLimitBars') || fields.includes('resetTimes')

  const s = []

  // Preamble
  s.push('#!/bin/bash')
  s.push('# Generated by claude-statusline wizard — re-run `npx claude-statusline` to reconfigure')
  s.push('set -euo pipefail')
  s.push('')

  // Colors
  if (hasColors) {
    s.push("G='\\033[32m'")
    s.push("Y='\\033[33m'")
    s.push("D='\\033[2m'")
    s.push("RED='\\033[31m'")
    s.push("R='\\033[0m'")
    s.push('')
  }

  // Rate limit cache paths
  if (needsRateLimits) {
    s.push('CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/claude-statusline"')
    s.push('USAGE_CACHE="$CACHE_DIR/usage.json"')
    s.push('USAGE_LOCK="$CACHE_DIR/usage.lock"')
    s.push('CACHE_MAX_AGE=60')
    s.push('CRED_FILE="$HOME/.claude/.credentials.json"')
    s.push('mkdir -p "$CACHE_DIR"')
    s.push('chmod 700 "$CACHE_DIR" 2>/dev/null || true')
    s.push('')
  }

  // Read stdin + parse (always parse superset — one cheap jq call)
  s.push('input=$(cat)')
  s.push('')
  s.push('parsed=""')
  s.push("parsed=$(echo \"$input\" | jq -r '[")
  s.push('  (.model.display_name // "Unknown"),')
  s.push('  (.context_window.total_input_tokens // 0),')
  s.push('  (.context_window.total_output_tokens // 0),')
  s.push('  (.context_window.context_window_size // 200000),')
  s.push('  (.context_window.used_percentage // 0),')
  s.push('  (.context_window.remaining_percentage // 0),')
  s.push('  (.cost.total_lines_added // 0),')
  s.push('  (.cost.total_lines_removed // 0),')
  s.push('  (.version // "unknown")')
  s.push("] | @tsv' 2>/dev/null) || parsed=\"\"")
  s.push('')
  s.push('if [[ -n "$parsed" ]]; then')
  s.push("  IFS=$'\\t' read -r model_name total_input total_output context_size used_pct remaining_pct \\")
  s.push('       lines_added lines_removed cc_version <<< "$parsed"')
  s.push('else')
  s.push('  model_name="Unknown"; total_input=0; total_output=0; context_size=200000')
  s.push('  used_pct=0; remaining_pct=0; lines_added=0; lines_removed=0; cc_version="unknown"')
  s.push('fi')
  s.push('')
  s.push('total_tokens=$((total_input + total_output))')
  s.push('remaining_tokens=$((context_size - total_tokens))')
  s.push('total_k=$((total_tokens / 1000))')
  s.push('context_k=$((context_size / 1000))')
  s.push('')

  // Helpers
  if (needsFmt) {
    s.push("fmt() { echo \"$1\" | sed -e :a -e 's/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta'; }")
    s.push('')
  }

  if (needsBar) {
    s.push('bar() {')
    s.push('  local pct="${1%%.*}"')
    s.push('  if ! [[ "$pct" =~ ^-?[0-9]+$ ]]; then echo "○○○○○○○○○○"; return; fi')
    s.push('  [[ "$pct" -gt 100 ]] && pct=100')
    s.push('  [[ "$pct" -lt 0 ]] && pct=0')
    s.push('  local filled=$((pct / 10)) empty=$((10 - filled)) out=""')
    s.push('  for ((i = 0; i < filled; i++)); do out+="●"; done')
    s.push('  for ((i = 0; i < empty; i++)); do out+="○"; done')
    s.push('  echo "$out"')
    s.push('}')
    s.push('')
  }

  if (hasColors) {
    const { yellow, red } = thresholds
    s.push('color_for_pct() {')
    s.push('  local pct="$1"')
    s.push('  if ! [[ "$pct" =~ ^[0-9]+$ ]]; then echo "$D"; return; fi')
    s.push(`  if [[ "$pct" -ge ${red} ]]; then echo "$RED"`)
    s.push(`  elif [[ "$pct" -ge ${yellow} ]]; then echo "$Y"`)
    s.push('  else echo "$G"; fi')
    s.push('}')
    s.push('')
  }

  // Rate limit fetch block
  if (needsRateLimits) {
    s.push(...rateLimitBlock())
  }

  // Output lines
  if (layout === 'single') {
    s.push(...buildSingleLine(fields, hasColors))
    s.push('printf "%b\\n" "$line1"')
  } else {
    s.push(...buildLine1(fields, hasColors))
    if (fields.includes('contextBar') || fields.includes('rateLimitBars')) {
      s.push(...buildLine2(fields, hasColors))
    }
    if (fields.includes('resetTimes')) {
      s.push(...buildLine3(hasColors))
    }
    const outputLines = ['line1']
    if (fields.includes('contextBar') || fields.includes('rateLimitBars')) outputLines.push('line2')
    if (fields.includes('resetTimes')) outputLines.push('line3')
    const fmtStr = outputLines.map(() => '%b').join('\\n')
    s.push(`printf "${fmtStr}\\n" ${outputLines.map(l => '"$' + l + '"').join(' ')}`)
  }

  return s.join('\n') + '\n'
}

// ── Private builders ──────────────────────────────────────────────

function buildSingleLine(fields, hasColors) {
  const [G, Y, R, RED] = hasColors
    ? ['${G}', '${Y}', '${R}', '${RED}']
    : ['', '', '', '']
  const parts = []
  if (fields.includes('model'))        parts.push(`${G}\${model_name}${R}`)
  if (fields.includes('tokenCounts'))  parts.push(`${G}\${total_k}k / \${context_k}k${R}`)
  if (fields.includes('usedPct'))      parts.push(`${Y}\${used_pct}% used $(fmt $total_tokens)${R}`)
  if (fields.includes('remainingPct')) parts.push(`${G}\${remaining_pct}% remain $(fmt $remaining_tokens)${R}`)
  const lines = [`line1="${parts.join(' | ')}"`]
  if (fields.includes('linesChanged')) {
    lines.push(`if [[ "$lines_added" != "0" ]] || [[ "$lines_removed" != "0" ]]; then`)
    lines.push(`  line1+=" | ${G}+\${lines_added}${R}/${RED}-\${lines_removed}${R}"`)
    lines.push('fi')
  }
  return lines
}

function buildLine1(fields, hasColors) {
  const [G, Y, R, RED] = hasColors
    ? ['${G}', '${Y}', '${R}', '${RED}']
    : ['', '', '', '']
  const parts = []
  if (fields.includes('model'))        parts.push(`${G}\${model_name}${R}`)
  if (fields.includes('tokenCounts'))  parts.push(`${G}\${total_k}k / \${context_k}k${R}`)
  if (fields.includes('usedPct'))      parts.push(`${Y}\${used_pct}% used $(fmt $total_tokens)${R}`)
  if (fields.includes('remainingPct')) parts.push(`${G}\${remaining_pct}% remain $(fmt $remaining_tokens)${R}`)
  const lines = [`line1="${parts.join(' | ')}"`]
  if (fields.includes('linesChanged')) {
    lines.push(`if [[ "$lines_added" != "0" ]] || [[ "$lines_removed" != "0" ]]; then`)
    lines.push(`  line1+=" | ${G}+\${lines_added}${R}/${RED}-\${lines_removed}${R}"`)
    lines.push('fi')
  }
  return lines
}

function buildLine2(fields, hasColors) {
  const [D, R] = hasColors ? ['${D}', '${R}'] : ['', '']
  const lines = []
  if (fields.includes('contextBar')) {
    const color = hasColors ? '$(color_for_pct "$used_pct")' : ''
    lines.push(`line2="${color}context: $(bar "$used_pct") \${used_pct}%${R}"`)
  } else {
    lines.push('line2=""')
  }
  if (fields.includes('rateLimitBars')) {
    const fhColor = hasColors ? '$(color_for_pct "$five_hour_pct")' : ''
    const wkColor = hasColors ? '$(color_for_pct "$weekly_pct")' : ''
    lines.push(`if [[ "$five_hour_pct" == "---" ]]; then`)
    lines.push(`  line2+=" | ${D}5-hour: $(bar "---") ---${R}"`)
    lines.push('else')
    lines.push(`  line2+=" | ${fhColor}5-hour: $(bar "$five_hour_pct") \${five_hour_pct}%${R}"`)
    lines.push('fi')
    lines.push(`if [[ "$weekly_pct" == "---" ]]; then`)
    lines.push(`  line2+=" | ${D}weekly: $(bar "---") ---${R}"`)
    lines.push('else')
    lines.push(`  line2+=" | ${wkColor}weekly: $(bar "$weekly_pct") \${weekly_pct}%${R}"`)
    lines.push('fi')
  }
  return lines
}

function buildLine3(hasColors) {
  const [D, R] = hasColors ? ['${D}', '${R}'] : ['', '']
  return [`line3="${D}5-hour resets \${five_hour_reset}${R} | ${D}weekly resets \${weekly_reset}${R}"`]
}

function rateLimitBlock() {
  return [
    'get_file_age() {',
    '  local file="$1"',
    '  if [[ "$(uname -s)" == "Darwin" ]]; then',
    "    stat -f '%m' \"$file\" 2>/dev/null || echo 999999",
    '  else',
    "    stat -c '%Y' \"$file\" 2>/dev/null || echo 999999",
    '  fi',
    '}',
    '',
    'get_access_token() {',
    '  if command -v security &>/dev/null; then',
    '    local j; j=$(security find-generic-password -s "Claude Code-credentials" -w 2>/dev/null) || true',
    "    if [[ -n \"$j\" ]]; then",
    "      local t; t=$(echo \"$j\" | jq -r '.claudeAiOauth.accessToken // empty' 2>/dev/null)",
    '      [[ -n "$t" ]] && { echo "$t"; return 0; }',
    '    fi',
    '  fi',
    '  [[ -f "$CRED_FILE" ]] && jq -r \'.claudeAiOauth.accessToken // empty\' "$CRED_FILE" 2>/dev/null && return 0',
    '  return 1',
    '}',
    '',
    'fetch_usage_bg() {',
    '  mkdir "$USAGE_LOCK" 2>/dev/null || {',
    '    local age; age=$(get_file_age "$USAGE_LOCK")',
    '    [[ "$age" -lt 30 ]] && return 0',
    '    rm -rf "$USAGE_LOCK"; mkdir "$USAGE_LOCK" 2>/dev/null || return 0',
    '  }',
    '  (',
    "    trap 'rm -rf \"$USAGE_LOCK\"' EXIT",
    '    local token; token=$(get_access_token) || exit 1',
    '    local tf; tf=$(mktemp "$CACHE_DIR/tok.XXXXXX"); chmod 600 "$tf"',
    "    printf 'Authorization: Bearer %s' \"$token\" > \"$tf\"",
    '    local resp; resp=$(curl -s --max-time 5 -H @"$tf" \\',
    '      -H "anthropic-beta: oauth-2025-04-20" -H "Accept: application/json" \\',
    '      "https://api.anthropic.com/api/oauth/usage" 2>/dev/null)',
    '    rm -f "$tf"',
    "    if echo \"$resp\" | jq -e '.five_hour' &>/dev/null; then",
    '      local tmp; tmp=$(mktemp "$CACHE_DIR/cache.XXXXXX")',
    '      echo "$resp" > "$tmp" && mv "$tmp" "$USAGE_CACHE"',
    '    fi',
    '  ) &',
    '  disown 2>/dev/null',
    '}',
    '',
    'five_hour_pct="---"; weekly_pct="---"; five_hour_reset="---"; weekly_reset="---"',
    'if [[ -f "$USAGE_CACHE" ]]; then',
    "  age=$(get_file_age \"$USAGE_CACHE\")",
    "  u=$(jq -r '[(.five_hour.utilization//-1|floor),(.five_hour.resets_at//\"\"),",
    '    ((.seven_day.utilization//-1)|floor),(.seven_day.resets_at//"")]',
    '    | @tsv\' "$USAGE_CACHE" 2>/dev/null) || u=""',
    '  if [[ -n "$u" ]]; then',
    "    IFS=$'\\t' read -r fh_p fh_r wk_p wk_r <<< \"$u\"",
    '    [[ "$fh_p" != "-1" ]] && five_hour_pct="$fh_p"',
    '    [[ "$wk_p" != "-1" ]] && weekly_pct="$wk_p"',
    '    [[ -n "$fh_r" ]] && five_hour_reset=$(format_reset_time "$fh_r")',
    '    [[ -n "$wk_r" ]] && weekly_reset=$(format_reset_time "$wk_r")',
    '  fi',
    '  [[ "$age" -ge "$CACHE_MAX_AGE" ]] && fetch_usage_bg',
    'else',
    '  fetch_usage_bg',
    'fi',
    '',
  ]
}
```

**Step 4: Run tests**

```bash
cd ~/code/claude-statusline && node --test test/generate.test.js
```

Expected: all tests pass (`✓` for each).

**Step 5: Commit**

```bash
cd ~/code/claude-statusline
git add lib/generate.js test/generate.test.js
git commit -m "feat: add generateScript() with tests"
```

---

### Task 3: lib/patch-settings.js

Pure function: takes raw JSON string + script path, returns updated JSON string with `statusLine` set.

**Files:**
- Create: `lib/patch-settings.js`
- Create: `test/patch-settings.test.js`

**Step 1: Write failing tests**

```js
// test/patch-settings.test.js
import { test } from 'node:test'
import assert from 'node:assert/strict'
import { applyStatusLine } from '../lib/patch-settings.js'

const DEST = '/Users/test/.claude/statusline-command.sh'

test('adds statusLine to empty object', () => {
  const parsed = JSON.parse(applyStatusLine('{}', DEST))
  assert.deepEqual(parsed.statusLine, { type: 'command', command: `/bin/bash ${DEST}` })
})

test('preserves existing keys', () => {
  const input = JSON.stringify({ permissions: { allow: ['Bash(git:*)'] }, model: 'sonnet' })
  const parsed = JSON.parse(applyStatusLine(input, DEST))
  assert.deepEqual(parsed.permissions, { allow: ['Bash(git:*)'] })
  assert.equal(parsed.model, 'sonnet')
})

test('overwrites existing statusLine', () => {
  const input = JSON.stringify({ statusLine: { type: 'command', command: '/old/path.sh' } })
  const parsed = JSON.parse(applyStatusLine(input, DEST))
  assert.equal(parsed.statusLine.command, `/bin/bash ${DEST}`)
})

test('throws on malformed JSON', () => {
  assert.throws(
    () => applyStatusLine('not json', DEST),
    { message: /malformed/ }
  )
})

test('output ends with newline', () => {
  assert.ok(applyStatusLine('{}', DEST).endsWith('\n'))
})
```

**Step 2: Run to confirm all fail**

```bash
cd ~/code/claude-statusline && node --test test/patch-settings.test.js
```

Expected: `ERR_MODULE_NOT_FOUND`.

**Step 3: Create `lib/patch-settings.js`**

```js
// lib/patch-settings.js
// Pure function — caller handles reading/writing the file.

export function applyStatusLine(rawJson, scriptPath) {
  let settings
  try {
    settings = JSON.parse(rawJson)
  } catch {
    throw new Error('~/.claude/settings.json is malformed JSON — aborting to avoid corruption')
  }
  settings.statusLine = { type: 'command', command: `/bin/bash ${scriptPath}` }
  return JSON.stringify(settings, null, 2) + '\n'
}
```

**Step 4: Run tests**

```bash
cd ~/code/claude-statusline && node --test test/patch-settings.test.js
```

Expected: all pass.

**Step 5: Commit**

```bash
cd ~/code/claude-statusline
git add lib/patch-settings.js test/patch-settings.test.js
git commit -m "feat: add applyStatusLine() with tests"
```

---

### Task 4: lib/detect-credentials.js

Checks whether OAuth credentials are present. Returns `true` → rate limit fields shown. Returns `false` → hidden.

Uses `execFileSync` (not `execSync`) to avoid shell injection — arguments are passed as an array, never interpolated into a shell string.

**Files:**
- Create: `lib/detect-credentials.js`

**Step 1: Create the module**

```js
// lib/detect-credentials.js
import { execFileSync } from 'node:child_process'
import { existsSync, readFileSync } from 'node:fs'
import { homedir } from 'node:os'

/**
 * Returns true if Claude Code OAuth credentials are accessible.
 * Checks macOS Keychain first, then ~/.claude/.credentials.json.
 * Uses execFileSync (not execSync) — no shell, no injection risk.
 */
export function detectCredentials() {
  // macOS Keychain
  try {
    const json = execFileSync(
      'security',
      ['find-generic-password', '-s', 'Claude Code-credentials', '-w'],
      { stdio: ['pipe', 'pipe', 'pipe'], encoding: 'utf8' }
    ).trim()
    if (json) {
      const parsed = JSON.parse(json)
      if (parsed?.claudeAiOauth?.accessToken) return true
    }
  } catch {
    // Not on macOS, no entry, or security binary not found — fall through
  }

  // Credentials file fallback
  const credFile = `${homedir()}/.claude/.credentials.json`
  if (existsSync(credFile)) {
    try {
      const parsed = JSON.parse(readFileSync(credFile, 'utf8'))
      if (parsed?.claudeAiOauth?.accessToken) return true
    } catch {
      // Malformed file — ignore
    }
  }

  return false
}
```

**Step 2: Smoke test**

```bash
cd ~/code/claude-statusline && node -e "
import('./lib/detect-credentials.js').then(m => console.log('hasCredentials:', m.detectCredentials()))
"
```

Expected: prints `hasCredentials: true` or `false` without crashing.

**Step 3: Commit**

```bash
cd ~/code/claude-statusline
git add lib/detect-credentials.js
git commit -m "feat: add detectCredentials() for account type detection"
```

---

### Task 5: setup.js — the wizard

Wires `@clack/prompts` + the three lib modules. Entry point for `npx claude-statusline`.

Preview uses `spawnSync('bash', [tmpScriptPath])` with `input` piped via stdin — no shell interpolation of user data.

**Files:**
- Create: `setup.js`

**Step 1: Create `setup.js`**

```js
#!/usr/bin/env node
// setup.js — interactive wizard for claude-statusline
import * as p from '@clack/prompts'
import { spawnSync } from 'node:child_process'
import { existsSync, readFileSync, writeFileSync, mkdirSync, unlinkSync } from 'node:fs'
import { homedir, tmpdir } from 'node:os'
import { join } from 'node:path'
import { generateScript } from './lib/generate.js'
import { applyStatusLine } from './lib/patch-settings.js'
import { detectCredentials } from './lib/detect-credentials.js'

const DEST     = join(homedir(), '.claude', 'statusline-command.sh')
const SETTINGS = join(homedir(), '.claude', 'settings.json')

p.intro('claude-statusline setup')

// Step 1: Detect account type
const hasRateLimits = detectCredentials()
if (!hasRateLimits) {
  p.log.info('No OAuth credentials found — rate limit fields hidden (Enterprise/API plan)')
}

// Step 2: Pick data fields
const alwaysOptions = [
  { value: 'model',        label: 'Model name' },
  { value: 'tokenCounts',  label: 'Token counts (used / total)' },
  { value: 'usedPct',      label: 'Used % with raw token count' },
  { value: 'remainingPct', label: 'Remaining % with raw token count' },
  { value: 'linesChanged', label: 'Lines changed (+added / -removed)' },
  { value: 'contextBar',   label: 'Context window progress bar' },
]
const rateLimitOptions = [
  { value: 'rateLimitBars', label: '5-hour & weekly rate limit bars' },
  { value: 'resetTimes',    label: 'Rate limit reset times' },
]

const fields = await p.multiselect({
  message: 'Which data fields do you want? (space to toggle, enter to confirm)',
  options: hasRateLimits ? [...alwaysOptions, ...rateLimitOptions] : alwaysOptions,
  initialValues: ['model', 'tokenCounts', 'usedPct', 'remainingPct', 'contextBar'],
  required: true,
})
if (p.isCancel(fields)) { p.cancel('Cancelled.'); process.exit(0) }

// Step 3: Layout
const layout = await p.select({
  message: 'Layout?',
  options: [
    { value: 'multi',  label: 'Multi-line  (model/tokens on line 1, bars on line 2)' },
    { value: 'single', label: 'Single line (everything on one line)' },
  ],
  initialValue: 'multi',
})
if (p.isCancel(layout)) { p.cancel('Cancelled.'); process.exit(0) }

// Step 4: Color style
const colorStyle = await p.select({
  message: 'Color style?',
  options: [
    { value: 'traffic-light', label: 'Traffic-light  (green <50%, yellow 50-79%, red >=80%)' },
    { value: 'monochrome',    label: 'Monochrome  (no colors)' },
    { value: 'custom',        label: 'Custom thresholds' },
  ],
  initialValue: 'traffic-light',
})
if (p.isCancel(colorStyle)) { p.cancel('Cancelled.'); process.exit(0) }

let thresholds = { yellow: 50, red: 80 }
if (colorStyle === 'custom') {
  const yellow = await p.text({
    message: 'Yellow threshold % (usage at/above this shows yellow)',
    placeholder: '50',
    validate: v => (isNaN(Number(v)) || Number(v) < 1 || Number(v) > 99) ? 'Enter 1-99' : undefined,
  })
  if (p.isCancel(yellow)) { p.cancel('Cancelled.'); process.exit(0) }

  const red = await p.text({
    message: 'Red threshold % (usage at/above this shows red)',
    placeholder: '80',
    validate: v => (isNaN(Number(v)) || Number(v) <= Number(yellow) || Number(v) > 100)
      ? `Enter ${Number(yellow) + 1}-100` : undefined,
  })
  if (p.isCancel(red)) { p.cancel('Cancelled.'); process.exit(0) }

  thresholds = { yellow: Number(yellow), red: Number(red) }
}

// Step 5: Preview
const config = { fields, layout, colorStyle, thresholds }
const script = generateScript(config)

const fakeInput = JSON.stringify({
  model: { display_name: 'Claude Sonnet 4.6 (1M context)' },
  context_window: {
    total_input_tokens: 45000,
    total_output_tokens: 3200,
    context_window_size: 1000000,
    used_percentage: 5,
    remaining_percentage: 95,
  },
  cost: { total_lines_added: 47, total_lines_removed: 12 },
  version: '1.0.0',
})

p.log.step('Preview (sample data):')
// Write script to temp file, pipe fake JSON to it via stdin.
// spawnSync args are an array — no shell, no injection risk.
const tmpScript = join(tmpdir(), `statusline-preview-${Date.now()}.sh`)
try {
  writeFileSync(tmpScript, script, { mode: 0o700 })
  const result = spawnSync('bash', [tmpScript], {
    input: fakeInput,
    encoding: 'utf8',
  })
  if (result.stdout) process.stdout.write(result.stdout)
  if (result.error) p.log.warn('Preview failed: ' + result.error.message)
} finally {
  try { unlinkSync(tmpScript) } catch { /* ignore */ }
}

// Step 6: Confirm and write
const ok = await p.confirm({
  message: `Write to ${DEST} and patch settings.json?`,
  initialValue: true,
})
if (p.isCancel(ok) || !ok) { p.cancel('Nothing written.'); process.exit(0) }

const spinner = p.spinner()
spinner.start('Writing files')

mkdirSync(join(homedir(), '.claude'), { recursive: true })
writeFileSync(DEST, script, { mode: 0o755 })

const rawSettings = existsSync(SETTINGS) ? readFileSync(SETTINGS, 'utf8') : '{}'
writeFileSync(SETTINGS, applyStatusLine(rawSettings, DEST))

spinner.stop('Done')
p.outro(`Restart Claude Code to see your new status line.\nRe-run \`npx claude-statusline\` any time to reconfigure.`)
```

**Step 2: Make executable**

```bash
chmod +x ~/code/claude-statusline/setup.js
```

**Step 3: Smoke test the full wizard**

```bash
cd ~/code/claude-statusline && node setup.js
```

Walk through all wizard steps. Verify:

```bash
# Script was written
ls -la ~/.claude/statusline-command.sh

# settings.json only changed statusLine key, everything else intact
cat ~/.claude/settings.json | jq '{statusLine, hasPermissions: (.permissions != null)}'
```

Expected output:
```json
{
  "statusLine": { "type": "command", "command": "/bin/bash /Users/.../.claude/statusline-command.sh" },
  "hasPermissions": true
}
```

**Step 4: Fix any issues, then commit**

```bash
cd ~/code/claude-statusline
git add setup.js
git commit -m "feat: add interactive CLI wizard"
```

---

### Task 6: Simplify install.sh

**Files:**
- Modify: `install.sh`

**Step 1: Replace install.sh**

```bash
#!/bin/bash
# Install claude-statusline — runs the interactive wizard
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

if ! command -v node &>/dev/null; then
  echo "Error: Node.js 18+ is required.  brew install node"
  exit 1
fi

if [ ! -d "$SCRIPT_DIR/node_modules/@clack" ]; then
  echo "Installing dependencies..."
  npm install --prefix "$SCRIPT_DIR" --silent
fi

node "$SCRIPT_DIR/setup.js"
```

**Step 2: Test**

```bash
cd ~/code/claude-statusline && bash install.sh
```

Expected: wizard launches.

**Step 3: Commit**

```bash
cd ~/code/claude-statusline
git add install.sh
git commit -m "chore: simplify install.sh to delegate to wizard"
```

---

### Task 7: Update README

**Files:**
- Modify: `README.md`

**Step 1: Replace install + usage sections**

Replace the current install block and everything below it with:

```markdown
## Install

```bash
npx claude-statusline
```

Or clone and run locally:

```bash
git clone https://github.com/aromanarguello/claude-statusline.git
cd claude-statusline
./install.sh
```

The wizard asks what data to show, how to format it, previews the result, then writes the script and patches `~/.claude/settings.json` (only the `statusLine` key — all other settings preserved).

## What you can configure

| Field | Description | Requires |
|-------|-------------|---------|
| Model name | Active Claude model | — |
| Token counts | Used / total context size | — |
| Used % | % of context used | — |
| Remaining % | % of context remaining | — |
| Lines changed | +added / -removed in session | — |
| Context bar | ●●●○○○○○○○ visual progress bar | — |
| Rate limit bars | 5-hour & weekly usage bars | Pro/Max/Team |
| Reset times | When rate limits reset | Pro/Max/Team |

**Enterprise/API users:** Rate limit fields are automatically hidden — the wizard detects your account type silently.

## Reconfigure

```bash
npx claude-statusline
```

Re-running the wizard overwrites `~/.claude/statusline-command.sh` with your new choices.

## Uninstall

```bash
cd claude-statusline && ./uninstall.sh
```
```

**Step 2: Commit**

```bash
cd ~/code/claude-statusline
git add README.md
git commit -m "docs: update README for wizard-based install"
```

---

## Final verification

```bash
cd ~/code/claude-statusline && node --test test/*.test.js
```

Expected: all tests pass. Then restart Claude Code to confirm the statusline renders.
